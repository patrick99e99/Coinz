#! /usr/bin/env ruby

require 'net/http'
require 'json'
require 'yaml'

class Coinz
  API_URL   = 'https://api.coinmarketcap.com/v1/ticker/?limit=2000'
  DELIMITER = ' / '

  def initialize
    self.total = 0
    process_tokens
    print_output
  end

  attr_accessor :total

  private

  def print_output
    system 'clear'

    separator

    sorted(processed_tokens).each { |holding| puts holding[:output] }

    separator
    total_amount
    separator
    puts
  end

  def holdings
    @holdings ||= {}
  end

  def processed_tokens
    holdings.map do |symbol, data|
      percentage = data[:value_in_usd] / total * 100
      formatted_percentage = formatted_number(percentage)
      spacer_1 = symbol.length == 3 ? '  ': ' '
      spacer_2 = percentage.to_s.length == 4 ? '  ': ' '
      {
        :symbol => symbol,
        :percentage => percentage,
        :output => "#{symbol}#{spacer_1}(#{formatted_percentage}%):#{spacer_2}#{data[:amount]} @ #{data[:current_price]} is worth: #{data[:values]}"
      }
    end
  end

  def sorted(collection)
    return collection unless sort
    sort_key = sort[:key]
    collection.sort do |a, b|

      if sort[:ascending]
        object_1 = a
        object_2 = b
      else
        object_1 = b
        object_2 = a
      end

      object_1[sort_key] <=> object_2[sort_key]
    end
  end

  def process_tokens
    if tokens.any?
      tokens.each do |ticker, amount|
        next if amount.to_i.zero?

        data = data_for('id', ticker)

        if !data
          puts "cannot find #{ticker}"
        else
          in_usd = usd_price_for(data) * amount
          holdings[data['symbol']] = { :amount => formatted_number(amount), :current_price => formatted_usd(usd_price_for(data)), :value_in_usd => in_usd, :values => prices_for(in_usd).join(DELIMITER) }

          self.total += in_usd
        end
      end
    else
      puts "NO TOKENS FOUND! - Add them to tokens.yml"
    end
  end

  def prices_for(in_usd)
    currencies.map do |currency|
      if currency == 'usd'
        formatted_usd(in_usd)
      else
        currency_data = data_for('symbol', currency)
        if !currency_data
          puts "cannot find #{currency}"
        else
          formatted_crypto(in_usd / usd_price_for(currency_data), currency)
        end
      end
    end
  end

  def btc_price_in_usd
    @btc_price ||= (overrides['btc'] ? overrides['btc'] : data_for('symbol', 'btc')['price_usd']).to_f
  end

  def usd_price_for(data)
    override = overrides[data['symbol'].downcase]
    (override ? override : data['price_usd']).to_f
  end

  def overrides
    @overrides ||= Hash[ARGV.map do |token|
      token.split('=').map {|item| item =~ /[a-z]/i ? item.downcase : item.to_f }
    end]
  end

  def currencies
    @currencies ||= overrides['currencies'] ? overrides['currencies'].split(',') : ['usd', 'btc']
  end

  def sort
    @sort ||= begin
      case overrides['sort'].to_s.downcase
      when /percent/
        { :key => :percentage, :ascending => false }
      when /sym/
        { :key => :symbol, :ascending => true }
      end
    end
  end

  def formatted_number(number)
    digits, fraction = number.to_s.split('.')
    amount = [digits.reverse.gsub(/...(?=.)/,'\&,').reverse].tap do |output|
      if fraction
        output.concat(['.', (fraction << '0')[0..1]])
      end
    end.join
  end

  def formatted_usd(number)
    "$#{formatted_number(number)}"
  end

  def formatted_crypto(number, symbol)
    formatted = number.to_s.scan(/\d+\.\d{3}/).last
    amount = formatted.nil? ? number : formatted
    "#{amount} #{symbol.upcase}"
  end

  def data_for(key, value)
    parsed_response.find do |entry|
      entry[key].downcase == value
    end
  end

  def separator
    puts "*" * characters
  end

  def characters
    @characters ||= begin
      `tput cols`.to_i
    rescue
      100
    end
  end

  def total_amount
    totals = currencies.map do |currency|
      if currency == 'usd'
        formatted_usd(total)
      else
        data = data_for('symbol', currency)
        if !data
          puts "cannot find #{currency}"
        else
          formatted_crypto(total / usd_price_for(data), data['symbol'])
        end
      end
    end

    puts "Total value of assets: #{totals.join(DELIMITER)}"
  end

  def parsed_response
    @parsed_response ||= begin
      response_body = Net::HTTP.get(URI.parse(API_URL))
      JSON.parse(response_body)
    end
  end

  def tokens
    @tokens ||= YAML.load_file(File.join(File.dirname(__FILE__), 'tokens.yml'))
  end
end

Coinz.new
